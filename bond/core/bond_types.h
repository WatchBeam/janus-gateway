
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
// 
//     Tool     : bondc, Version=3.0.1, Build=bond-git.retail.not
//     Template : Microsoft.Bond.Rules.dll#Rules_BOND_CPP.tt
//     File     : bond_types.h
//
//     Changes to this file may cause incorrect behavior and will be lost when
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
    

#pragma once


#include <bond/core/bond_version.h>
#if BOND_MAJOR_VERSION_MIN_SUPPORTED > 3 \
    || (BOND_MAJOR_VERSION_MIN_SUPPORTED == 3 && BOND_MINOR_VERSION_MIN_SUPPORTED > 0) 
#error This file was generated by an older Bond compiler which is \
       incompatible with current Bond library. Please regenerate \
       with the latest Bond compiler.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>
#include <bond/core/nullable.h>
#include "bond_const_types.h"
#include "bond_enum.h"

namespace bond
{

// SerializableExceptionBase 
struct SerializableExceptionBase 
{
    // 8189: optional string m_message
    std::string m_message;
    
    SerializableExceptionBase()
    {
    }


    // Compiler generated copy ctor OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    SerializableExceptionBase(const SerializableExceptionBase& rhs) = default;
#endif


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    SerializableExceptionBase(SerializableExceptionBase&& rhs)
        : m_message(std::move(rhs.m_message))
    {     
    }
#endif
    
    
    template<typename Allocator>
    explicit
    SerializableExceptionBase(Allocator* allocator)
        : m_message(*allocator)
    {
    }


    // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    SerializableExceptionBase& operator=(const SerializableExceptionBase& rhs) = default;
#endif


    bool operator==(const SerializableExceptionBase& other) const
    {
        return true
            && (m_message == other.m_message);
    }


    bool operator!=(const SerializableExceptionBase& other) const
    {
        return !(*this == other);
    }


    void swap(SerializableExceptionBase& other)
    {
        using std::swap;
        swap(m_message, other.m_message);
    }

    
    struct Schema;


protected:    
    void InitMetadata(const char* /*name*/, const char* /*full_name*/)
    {
    }
};


inline void swap(SerializableExceptionBase& left, SerializableExceptionBase& right)
{
    left.swap(right);
}



// Represents void type 
struct Void 
{
    Void()
    {
    }


    // Compiler generated copy ctor OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    Void(const Void& rhs) = default;
#endif


    // Compiler generated move ctor OK


    template<typename Allocator>
    explicit
    Void(Allocator* /*allocator*/)
    {
    }


    // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    Void& operator=(const Void& rhs) = default;
#endif



    bool operator==(const Void& /*other*/) const
    {
        return true;
    }


    bool operator!=(const Void& other) const
    {
        return !(*this == other);
    }


    void swap(Void& /*other*/)
    {
        using std::swap;
    }

    
    struct Schema;


protected:    
    void InitMetadata(const char* /*name*/, const char* /*full_name*/)
    {
    }
};


inline void swap(Void& left, Void& right)
{
    left.swap(right);
}



// Structure with the same memory layout as Windows GUID 
struct GUID 
{
    // 0: optional uint32 Data1
    uint32_t Data1;
    
    // 1: optional uint16 Data2
    uint16_t Data2;
    
    // 2: optional uint16 Data3
    uint16_t Data3;
    
    // 3: optional uint64 Data4
    uint64_t Data4;
    
    GUID()
        : Data1(),
          Data2(),
          Data3(),
          Data4()
    {
    }


    // Compiler generated copy ctor OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    GUID(const GUID& rhs) = default;
#endif


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    GUID(GUID&& rhs)
        : Data1(std::move(rhs.Data1)),
          Data2(std::move(rhs.Data2)),
          Data3(std::move(rhs.Data3)),
          Data4(std::move(rhs.Data4))
    {     
    }
#endif
    
    
    template<typename Allocator>
    explicit
    GUID(Allocator* /*allocator*/)
        : Data1(),
          Data2(),
          Data3(),
          Data4()
    {
    }


    // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    GUID& operator=(const GUID& rhs) = default;
#endif


    bool operator==(const GUID& other) const
    {
        return true
            && (Data1 == other.Data1)
            && (Data2 == other.Data2)
            && (Data3 == other.Data3)
            && (Data4 == other.Data4);
    }


    bool operator!=(const GUID& other) const
    {
        return !(*this == other);
    }


    void swap(GUID& other)
    {
        using std::swap;
        swap(Data1, other.Data1);
        swap(Data2, other.Data2);
        swap(Data3, other.Data3);
        swap(Data4, other.Data4);
    }

    
    struct Schema;


protected:    
    void InitMetadata(const char* /*name*/, const char* /*full_name*/)
    {
    }
};


inline void swap(GUID& left, GUID& right)
{
    left.swap(right);
}


namespace _bond_enumerators
{
namespace Modifier
{


extern const std::map<enum Modifier, std::string> _value_to_name_Modifier;
extern const std::map<std::string, enum Modifier> _name_to_value_Modifier;

inline 
const char* GetTypeName(enum Modifier)
{
    return "Modifier";
}

inline 
const char* GetTypeName(enum Modifier, const bond::qualified_name_tag&)
{
    return "bond.Modifier";
}

inline 
const std::map<enum Modifier, std::string>& GetValueToNameMap(enum Modifier)
{
    return ::bond::_bond_enumerators::Modifier::_value_to_name_Modifier;
}

inline 
const std::map<std::string, enum Modifier>& GetNameToValueMap(enum Modifier)
{
    return ::bond::_bond_enumerators::Modifier::_name_to_value_Modifier;
}

inline 
const std::string& ToString(enum Modifier value)
{
    std::map<enum Modifier, std::string>::const_iterator it = 
        GetValueToNameMap(value).find(value);

    if (GetValueToNameMap(value).end() == it)
        bond::InvalidEnumValueException(value, "Modifier");
    
    return it->second;
}

inline 
void FromString(const std::string& name, enum Modifier& value)
{
    std::map<std::string, enum Modifier>::const_iterator it = 
        ::bond::_bond_enumerators::Modifier::_name_to_value_Modifier.find(name);

    if (::bond::_bond_enumerators::Modifier::_name_to_value_Modifier.end() == it)
        bond::InvalidEnumValueException(name.c_str(), "Modifier");
    
    value = it->second;
}

inline 
bool ToEnum(enum Modifier& value, const std::string& name)
{
    std::map<std::string, enum Modifier>::const_iterator it = 
        ::bond::_bond_enumerators::Modifier::_name_to_value_Modifier.find(name);

    if (::bond::_bond_enumerators::Modifier::_name_to_value_Modifier.end() == it)
        return false;
    
    value = it->second;

    return true;
}

}  // namespace Modifier
}  // namespace _bond_enumerators


// Variant struct is used to store a value of one of the basic Bond types 
struct Variant 
{
    // 0: optional uint64 uint_value
    uint64_t uint_value;
    
    // 1: optional int64 int_value
    int64_t int_value;
    
    // 2: optional double double_value
    double double_value;
    
    // 3: optional string string_value
    std::string string_value;
    
    // 4: optional wstring wstring_value
    std::wstring wstring_value;
    
    // 5: optional bool nothing
    bool nothing;
    
    Variant()
        : uint_value(),
          int_value(),
          double_value(),
          nothing()
    {
    }


    // Compiler generated copy ctor OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    Variant(const Variant& rhs) = default;
#endif


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    Variant(Variant&& rhs)
        : uint_value(std::move(rhs.uint_value)),
          int_value(std::move(rhs.int_value)),
          double_value(std::move(rhs.double_value)),
          string_value(std::move(rhs.string_value)),
          wstring_value(std::move(rhs.wstring_value)),
          nothing(std::move(rhs.nothing))
    {     
    }
#endif
    
    
    template<typename Allocator>
    explicit
    Variant(Allocator* allocator)
        : uint_value(),
          int_value(),
          double_value(),
          string_value(*allocator),
          wstring_value(*allocator),
          nothing()
    {
    }


    // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    Variant& operator=(const Variant& rhs) = default;
#endif


    bool operator==(const Variant& other) const
    {
        return true
            && (uint_value == other.uint_value)
            && (int_value == other.int_value)
            && (double_value == other.double_value)
            && (string_value == other.string_value)
            && (wstring_value == other.wstring_value)
            && (nothing == other.nothing);
    }


    bool operator!=(const Variant& other) const
    {
        return !(*this == other);
    }


    void swap(Variant& other)
    {
        using std::swap;
        swap(uint_value, other.uint_value);
        swap(int_value, other.int_value);
        swap(double_value, other.double_value);
        swap(string_value, other.string_value);
        swap(wstring_value, other.wstring_value);
        swap(nothing, other.nothing);
    }

    
    struct Schema;


protected:    
    void InitMetadata(const char* /*name*/, const char* /*full_name*/)
    {
    }
};


inline void swap(Variant& left, Variant& right)
{
    left.swap(right);
}



// Metadata 
struct Metadata 
{
    // 0: optional string name
    // Name of the field or struct
    std::string name;
    
    // 1: optional string qualified_name
    // Fully qualified name, used only for structs
    std::string qualified_name;
    
    // 2: optional map<string, string> attributes
    // Attributes
    std::map<std::string, std::string> attributes;
    
    // 3: optional bond.Modifier modifier
    // Field modifier, not used for structs
    ::bond::Modifier modifier;
    
    // 4: optional bond.Variant default_value
    // Default value of the field, not used for structs
    ::bond::Variant default_value;
    
    Metadata()
        : modifier(::bond::_bond_enumerators::Modifier::Optional)
    {
    }


    // Compiler generated copy ctor OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    Metadata(const Metadata& rhs) = default;
#endif


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    Metadata(Metadata&& rhs)
        : name(std::move(rhs.name)),
          qualified_name(std::move(rhs.qualified_name)),
          attributes(std::move(rhs.attributes)),
          modifier(std::move(rhs.modifier)),
          default_value(std::move(rhs.default_value))
    {     
    }
#endif
    
    
    template<typename Allocator>
    explicit
    Metadata(Allocator* allocator)
        : name(*allocator),
          qualified_name(*allocator),
          attributes(std::less<std::string>(), *allocator),
          modifier(::bond::_bond_enumerators::Modifier::Optional),
          default_value(allocator)
    {
    }


    // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    Metadata& operator=(const Metadata& rhs) = default;
#endif


    bool operator==(const Metadata& other) const
    {
        return true
            && (name == other.name)
            && (qualified_name == other.qualified_name)
            && (attributes == other.attributes)
            && (modifier == other.modifier)
            && (default_value == other.default_value);
    }


    bool operator!=(const Metadata& other) const
    {
        return !(*this == other);
    }


    void swap(Metadata& other)
    {
        using std::swap;
        swap(name, other.name);
        swap(qualified_name, other.qualified_name);
        swap(attributes, other.attributes);
        swap(modifier, other.modifier);
        swap(default_value, other.default_value);
    }

    
    struct Schema;


protected:    
    void InitMetadata(const char* /*name*/, const char* /*full_name*/)
    {
    }
};


inline void swap(Metadata& left, Metadata& right)
{
    left.swap(right);
}



// TypeDef 
struct TypeDef 
{
    // 0: optional bond.BondDataType id
    // Type identifier
    ::bond::BondDataType id;
    
    // 1: optional uint16 struct_def
    // Default: 0
    // Index of struct definition in SchemaDef.structs when id == BT_STRUCT
    uint16_t struct_def;
    
    // 2: optional nullable<bond.TypeDef> element
    // Type definition for: list elements (id == BT_LIST), set elements (id == BT_SET), or mapped value (id == BT_MAP)
    bond::nullable< ::bond::TypeDef> element;
    
    // 3: optional nullable<bond.TypeDef> key
    // Type definition for map key when id == BT_MAP
    bond::nullable< ::bond::TypeDef> key;
    
    // 4: optional bool bonded_type
    // True if the type is bonded<T>; used only when id == BT_STRUCT
    bool bonded_type;
    
    TypeDef()
        : id(::bond::_bond_enumerators::BondDataType::BT_STRUCT),
          struct_def(0),
          bonded_type()
    {
    }


    // Compiler generated copy ctor OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    TypeDef(const TypeDef& rhs) = default;
#endif


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    TypeDef(TypeDef&& rhs)
        : id(std::move(rhs.id)),
          struct_def(std::move(rhs.struct_def)),
          element(std::move(rhs.element)),
          key(std::move(rhs.key)),
          bonded_type(std::move(rhs.bonded_type))
    {     
    }
#endif
    
    
    template<typename Allocator>
    explicit
    TypeDef(Allocator* allocator)
        : id(::bond::_bond_enumerators::BondDataType::BT_STRUCT),
          struct_def(0),
          element(*allocator),
          key(*allocator),
          bonded_type()
    {
    }


    // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    TypeDef& operator=(const TypeDef& rhs) = default;
#endif


    bool operator==(const TypeDef& other) const
    {
        return true
            && (id == other.id)
            && (struct_def == other.struct_def)
            && (element == other.element)
            && (key == other.key)
            && (bonded_type == other.bonded_type);
    }


    bool operator!=(const TypeDef& other) const
    {
        return !(*this == other);
    }


    void swap(TypeDef& other)
    {
        using std::swap;
        swap(id, other.id);
        swap(struct_def, other.struct_def);
        swap(element, other.element);
        swap(key, other.key);
        swap(bonded_type, other.bonded_type);
    }

    
    struct Schema;


protected:    
    void InitMetadata(const char* /*name*/, const char* /*full_name*/)
    {
    }
};


inline void swap(TypeDef& left, TypeDef& right)
{
    left.swap(right);
}



// FieldDef 
struct FieldDef 
{
    // 0: optional bond.Metadata metadata
    // Field metadata
    ::bond::Metadata metadata;
    
    // 1: optional uint16 id
    // Field ordinal
    uint16_t id;
    
    // 2: optional bond.TypeDef type
    // Field type definition
    ::bond::TypeDef type;
    
    FieldDef()
        : id()
    {
    }


    // Compiler generated copy ctor OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    FieldDef(const FieldDef& rhs) = default;
#endif


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    FieldDef(FieldDef&& rhs)
        : metadata(std::move(rhs.metadata)),
          id(std::move(rhs.id)),
          type(std::move(rhs.type))
    {     
    }
#endif
    
    
    template<typename Allocator>
    explicit
    FieldDef(Allocator* allocator)
        : metadata(allocator),
          id(),
          type(allocator)
    {
    }


    // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    FieldDef& operator=(const FieldDef& rhs) = default;
#endif


    bool operator==(const FieldDef& other) const
    {
        return true
            && (metadata == other.metadata)
            && (id == other.id)
            && (type == other.type);
    }


    bool operator!=(const FieldDef& other) const
    {
        return !(*this == other);
    }


    void swap(FieldDef& other)
    {
        using std::swap;
        swap(metadata, other.metadata);
        swap(id, other.id);
        swap(type, other.type);
    }

    
    struct Schema;


protected:    
    void InitMetadata(const char* /*name*/, const char* /*full_name*/)
    {
    }
};


inline void swap(FieldDef& left, FieldDef& right)
{
    left.swap(right);
}



// StructDef 
struct StructDef 
{
    // 0: optional bond.Metadata metadata
    // Struct metadata
    ::bond::Metadata metadata;
    
    // 1: optional nullable<bond.TypeDef> base_def
    // Type definition of base struct
    bond::nullable< ::bond::TypeDef> base_def;
    
    // 2: optional vector<bond.FieldDef> fields
    // List of field definitions
    std::vector< ::bond::FieldDef> fields;
    
    StructDef()
    {
    }


    // Compiler generated copy ctor OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    StructDef(const StructDef& rhs) = default;
#endif


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    StructDef(StructDef&& rhs)
        : metadata(std::move(rhs.metadata)),
          base_def(std::move(rhs.base_def)),
          fields(std::move(rhs.fields))
    {     
    }
#endif
    
    
    template<typename Allocator>
    explicit
    StructDef(Allocator* allocator)
        : metadata(allocator),
          base_def(*allocator),
          fields(*allocator)
    {
    }


    // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    StructDef& operator=(const StructDef& rhs) = default;
#endif


    bool operator==(const StructDef& other) const
    {
        return true
            && (metadata == other.metadata)
            && (base_def == other.base_def)
            && (fields == other.fields);
    }


    bool operator!=(const StructDef& other) const
    {
        return !(*this == other);
    }


    void swap(StructDef& other)
    {
        using std::swap;
        swap(metadata, other.metadata);
        swap(base_def, other.base_def);
        swap(fields, other.fields);
    }

    
    struct Schema;


protected:    
    void InitMetadata(const char* /*name*/, const char* /*full_name*/)
    {
    }
};


inline void swap(StructDef& left, StructDef& right)
{
    left.swap(right);
}



// Type used to serialize schema 
struct SchemaDef 
{
    // 0: optional vector<bond.StructDef> structs
    // List of struct definitions referenced in the schema
    std::vector< ::bond::StructDef> structs;
    
    // 1: optional bond.TypeDef root
    // Root struct of the schema
    ::bond::TypeDef root;
    
    SchemaDef()
    {
    }


    // Compiler generated copy ctor OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    SchemaDef(const SchemaDef& rhs) = default;
#endif


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    SchemaDef(SchemaDef&& rhs)
        : structs(std::move(rhs.structs)),
          root(std::move(rhs.root))
    {     
    }
#endif
    
    
    template<typename Allocator>
    explicit
    SchemaDef(Allocator* allocator)
        : structs(*allocator),
          root(allocator)
    {
    }


    // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    SchemaDef& operator=(const SchemaDef& rhs) = default;
#endif


    bool operator==(const SchemaDef& other) const
    {
        return true
            && (structs == other.structs)
            && (root == other.root);
    }


    bool operator!=(const SchemaDef& other) const
    {
        return !(*this == other);
    }


    void swap(SchemaDef& other)
    {
        using std::swap;
        swap(structs, other.structs);
        swap(root, other.root);
    }

    
    struct Schema;


protected:    
    void InitMetadata(const char* /*name*/, const char* /*full_name*/)
    {
    }
};


inline void swap(SchemaDef& left, SchemaDef& right)
{
    left.swap(right);
}



// Box 
template <typename T>
struct Box 
{
    // 0: optional T value
    T value;
    
    Box()
        : value()
    {
    }


    // Compiler generated copy ctor OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    Box(const Box& rhs) = default;
#endif


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    Box(Box&& rhs)
        : value(std::move(rhs.value))
    {     
    }
#endif
    
    
    template<typename Allocator>
    explicit
    Box(Allocator* /*allocator*/)
        : value()
    {
    }


    // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    Box& operator=(const Box& rhs) = default;
#endif


    bool operator==(const Box& other) const
    {
        return true
            && (value == other.value);
    }


    bool operator!=(const Box& other) const
    {
        return !(*this == other);
    }


    void swap(Box& other)
    {
        using std::swap;
        swap(value, other.value);
    }

    
    struct Schema;


protected:    
    void InitMetadata(const char* /*name*/, const char* /*full_name*/)
    {
    }
};


template <typename T>
inline void swap(Box<T>& left, Box<T>& right)
{
    left.swap(right);
}



// List 
template <typename T, typename U>
struct List 
{
    // 0: optional list<T> value
    std::list<T> value;
    
    List()
    {
    }


    // Compiler generated copy ctor OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    List(const List& rhs) = default;
#endif


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    List(List&& rhs)
        : value(std::move(rhs.value))
    {     
    }
#endif
    
    
    template<typename Allocator>
    explicit
    List(Allocator* allocator)
        : value(*allocator)
    {
    }


    // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    List& operator=(const List& rhs) = default;
#endif


    bool operator==(const List& other) const
    {
        return true
            && (value == other.value);
    }


    bool operator!=(const List& other) const
    {
        return !(*this == other);
    }


    void swap(List& other)
    {
        using std::swap;
        swap(value, other.value);
    }

    
    struct Schema;


protected:    
    void InitMetadata(const char* /*name*/, const char* /*full_name*/)
    {
    }
};


template <typename T, typename U>
inline void swap(List<T, U>& left, List<T, U>& right)
{
    left.swap(right);
}



// Vector 
template <typename T, typename U>
struct Vector 
{
    // 0: optional vector<T> value
    std::vector<T> value;
    
    Vector()
    {
    }


    // Compiler generated copy ctor OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    Vector(const Vector& rhs) = default;
#endif


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    Vector(Vector&& rhs)
        : value(std::move(rhs.value))
    {     
    }
#endif
    
    
    template<typename Allocator>
    explicit
    Vector(Allocator* allocator)
        : value(*allocator)
    {
    }


    // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    Vector& operator=(const Vector& rhs) = default;
#endif


    bool operator==(const Vector& other) const
    {
        return true
            && (value == other.value);
    }


    bool operator!=(const Vector& other) const
    {
        return !(*this == other);
    }


    void swap(Vector& other)
    {
        using std::swap;
        swap(value, other.value);
    }

    
    struct Schema;


protected:    
    void InitMetadata(const char* /*name*/, const char* /*full_name*/)
    {
    }
};


template <typename T, typename U>
inline void swap(Vector<T, U>& left, Vector<T, U>& right)
{
    left.swap(right);
}



// Polymorphic 
// [polymorphic("")]
struct Polymorphic 
{
    // 32768: required_optional bond_meta::full_name bond_meta
    std::string bond_meta;
    
    Polymorphic()      
    {  
        InitMetadata("Polymorphic", "bond.Polymorphic");
    }


    Polymorphic(const Polymorphic& rhs)
        : bond_meta(rhs.bond_meta.get_allocator())      
    {  
        InitMetadata("Polymorphic", "bond.Polymorphic");
    }


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    Polymorphic(Polymorphic&& rhs)
        : bond_meta(std::move(rhs.bond_meta))
    {     
    }
#endif
    
    
    template<typename Allocator>
    explicit
    Polymorphic(Allocator* allocator)
        : bond_meta(*allocator)      
    {  
        InitMetadata("Polymorphic", "bond.Polymorphic");
    }


    Polymorphic& operator=(const Polymorphic& rhs)
    {
        Polymorphic(rhs).swap(*this);
        return *this;
    }



    bool operator==(const Polymorphic& /*other*/) const
    {
        return true;
        // skip bond_meta::full_name field 'bond_meta'
    }


    bool operator!=(const Polymorphic& other) const
    {
        return !(*this == other);
    }


    void swap(Polymorphic& /*other*/)
    {
        using std::swap;
        // skip bond_meta::full_name field 'bond_meta'
    }

    
    struct Schema;


protected:    
    void InitMetadata(const char* /*name*/, const char* full_name)
    {
        this->bond_meta = full_name;
    }
};


inline void swap(Polymorphic& left, Polymorphic& right)
{
    left.swap(right);
}



} // namespace bond
